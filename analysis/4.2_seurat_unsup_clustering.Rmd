---
title: "CosMx Data Seurat Unsupervised Clustering and scType annotation"
author: 
  - name: "LGA"
date: "`r format(Sys.Date(), '%d %B %Y')`"
site: workflowr::wflow_site
output: workflowr::wflow_html
editor_options:
  chunk_output_type: inline
---

<!-- This pipeline has been developed using Seurat v4.4, as Seurat v5 presents several changes to the object structure that affected the working methods. Aditionally, the AtoMx exported Seurat objects come in the Seurat v4 structure. Therefore, working in this version can be more compatible with exported data too.-->

```{r setup, include = FALSE}
# Read utils
source(
  here::here("code", "utils.R"), 
  local = knitr::knit_global())

source(
  here::here("code", "aux_functions.R"), 
  local = knitr::knit_global())

# Setup chunk options
# By reading *utils.R*, the *chunk hook* function "monitor" can be included
knitr::opts_chunk$set(
  message = FALSE,
  warning = FALSE,
  monitor = TRUE, # Self created chunk hook to monitor time and memory usage
  error = TRUE
)
```

# Dependencies

```{r Libraries, message = FALSE}
library(data.table) # Efficient data management
library(here) # Enhanced file referencing in project-oriented workflows
library(dplyr) # For the use of pipes %>%
library(kableExtra) # For table formatting
library(Seurat) # Seurat object
library(ggplot2) # Graphics
library(patchwork) # Layout graphics
library(clustree) # Plot cluster resolutions
library(HGNChelper) # For scType annotation
```

# Load the data

First of all, data needs to be loaded into the session. For this script, only the Seurat object is needed.  

The Seurat package provides an unsupervised cell clustering method, where cells clusters are identified based in the shared nearest neighbor (SNN) and calculated via Louvain algorithm for modularity optimization.   

```{r LoadData}
# Indicate the object folder
folder <- "SCT" # Choose between "RC", "Log" or "SCT"

if (!folder %in% c("RC", "Log", "SCT")) {
  stop("The selected folder is invalid, choose: 'RC', 'Log' or 'SCT'")
}

# Load Seurat object
name <- paste0("seu_", folder, "_um.RDS")
seu <- readRDS(here("output","processed_data",folder,name))

# Load the number of PCs used for dimensional reduction
name <- paste0("npcs_", folder, ".RDS")
npcs <- readRDS(here("output","processed_data",folder,name))
```

# Clustering with Seurat-Louvain

First, the SNN graph is constructed using the "FindNeighbors" function by Seurat. Then, "FindClusters" function is apply to identify clusters based on the SNN graph. For this step, it is usually recommended to check different resolutions and explore the results to select the more biologically meaningful number of clusters.  

This method is used in the [CosMxLite vignette](https://github.com/cancerbioinformatics/CosMx_Lite/tree/main/scripts), where a resolution < 1.0 is suggested for CosMx data. However, note that it was developed for single-cell genomic data and only utilities gene expression information for clustering.  

```{r SNNClust}
## Code inspired by CosMxLite vignette

# Find Neighbors 
seu <- FindNeighbors(seu, reduction = "pca", dims = 1:npcs) # Same PCs as in UMAP

# Cluster at different resolutions
resolutions <- seq(0.1, 0.6, by = 0.1) # Change range if needed
seu <- FindClusters(seu, resolution = resolutions, verbose = FALSE)
```

## Resolutions exploration

To examine different cluster resolutions there are different approaches, this pipeline will follow CosMxLite procedure and perform a "Clustree" plot and a UMAP cluster representation comparison.  

```{r VizRes1, fig.width = 7, fig.height = 7}
## Code adapted from CosMxLite vignette

# Set resolution slot prefix depending on normalization
if (folder == "SCT") {
  slot <- "SCT"
} else {
  slot <- "RNA"  
}

prefix <- paste0(slot,"_snn_res.")

# Inspect clustering resolutions
clustree(seu, prefix = prefix, return = "plot")
```

The "Clustree" plot shows the number and size of clusters at each resolution and how they change with increasing resolutions. In this example, it can be observed that, in general, most cell groups are very defined from the beginning and remain very stable with growing resolutions. So the right choice here could be based on the level of detailed desired or having a look at the UMAP plots.  

```{r VizRes2, fig.width = 15, fig.height = 10}
## Code inspired by CosMxLite vignette

# Inspect UMAP clustering resolutions
plots <- lapply(resolutions, function(res) {
  DimPlot(seu, reduction = "umap", label = TRUE, raster = FALSE, group.by = paste0(prefix, res)) + NoLegend()
  })

# Arrange plots
wrap_plots(plots, ncol = 3)
```

In sight of the UMAP representations, the 0.1 resolution could be a good fit if not a great level of detail is needed, while higher resolutions seem to differentiate sub-populations. For this example, resolution of 0.1 seems enough.    

```{r SetRes}
## Code adapted from CosMxLite vignette

# Select a resolution
res_select <- 0.1 # Change if needed
res_select_name <- paste0(prefix,res_select)

# Set the selected resolution as default
Idents(seu) <- seu@meta.data[[paste0(prefix,res_select)]]
seu$seurat_clusters <- seu@meta.data[[paste0(prefix,res_select)]]
```

## Clustering visualizations

Now that the selected resolution has been established as the reference clustering os the Seurat object, some visualizations are useful to further inspect the resulting clusters:  

```{r VizClus1, fig.width = 6, fig.height = 5}
# Create custom color palette
n <- length(unique(Idents(seu)))
cols <- gg_color_hue(n)

# DimPlot of selected resolution
clus_plot <- DimPlot(seu, reduction = "umap", label = TRUE, 
                     cols = cols, raster = FALSE)
clus_plot
```

Finally, the visualization of "nFeature" and "nCount" allows to identify clusters with better/lower representation by the CosMx panel.  

```{r VizClus2, fig.width = 8, fig.height = 5}
## Code adapted from CosMxLite vignette
## Points are removed as CosMx datasets can contain over 1 million cells and may hide the violin plot

# Violin plot
VlnPlot(seu, features = c("nFeature_RNA", "nCount_RNA"), ncol = 1, pt.size = 0, 
        group.by = "seurat_clusters")
```

# Cell annotation - scType

In this script, clusters will be annotated based on their top markers using the "scType" package and its "Brain" reference. For more information about this method check its documentation and vignette  [here](https://github.com/IanevskiAleksandr/sc-type).

```{r scTypePrep}
## Code adapted from scType vignette

# Load gene set preparation and cell type annotation function
source("https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/R/gene_sets_prepare.R")
source("https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/R/sctype_score_.R")

# Prepare DB file and select tissue
db_ <- "https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/ScTypeDB_full.xlsx";
tissue <- "Brain" # e.g. Immune system, Pancreas, Liver, Kidney, Brain...

# Prepare gene sets
gs_list <- gene_sets_prepare(db_, tissue)

# Extract scaled data from the Seurat object
scaled_data <- as.matrix(seu[[paste0(slot)]]@scale.data) 
```

```{r RunscType}
## Code adapted from scType vignette

# Run ScType
es.max <- sctype_score(scaled_data, scaled = TRUE, 
                       gs = gs_list$gs_positive, 
                       gs2 = gs_list$gs_negative)

# Merge by cluster
cL_resutls <- do.call("rbind", lapply(unique(seu@meta.data$seurat_clusters), function(cl) {
    es.max.cl = sort(rowSums(es.max[ ,rownames(seu@meta.data[seu@meta.data$seurat_clusters==cl, ])]), 
                     decreasing = !0)
    head(data.frame(cluster = cl, type = names(es.max.cl), scores = es.max.cl, 
                    ncells = sum(seu@meta.data$seurat_clusters==cl)), 10)
}))

sctype_scores <- cL_resutls %>% group_by(cluster) %>% top_n(n = 1, wt = scores)

# Set low-confident (low ScType score) clusters to "unknown"
sctype_scores$type[as.numeric(as.character(sctype_scores$scores)) < sctype_scores$ncells/4] <- "Unknown"

## Self coded addition
# Maintain original cluster separation
sctype_scores$cl_type <- paste0(sctype_scores$cluster, "_", sctype_scores$type)

# Sort by cluster
sctype_scores <- sctype_scores %>% arrange(as.numeric(sctype_scores$cluster))
print(sctype_scores)
```

In this case the "Brain" database has confidently annotated all clusters and merged a few clusters that got the same label, for example, clusters 2, 6, 10 and 16 as GABAergic neurons, or 0, 8 and 9 as Glutamatergic neurons , and 5 and 14 as Cancer stem cells.  

## Add clustering to Seurat object

In order not to loose information, both the scType annotation and a "cluster+scType" annotation will be saved in the seurat object.  

```{r AddAnn}
# Convert to data.frame and select columns
annot_df <- sctype_scores %>% 
  dplyr::select(cluster, type, cl_type) %>%
  dplyr::mutate(cluster = as.character(cluster))

# Create named vectors for easy mapping
scType_ann <- setNames(annot_df$type, annot_df$cluster)
cl_scType_ann <- setNames(annot_df$cl_type, annot_df$cluster)

# Add new metadata columns to seurat object
seu$scType_ann <- factor(scType_ann[as.character(seu$seurat_clusters)],
                         levels = unique(annot_df$type))

seu$cl_scType_ann <- factor(cl_scType_ann[as.character(seu$seurat_clusters)],
                            levels = annot_df$cl_type)

# Set the scType annotation as default
Idents(seu) <- seu$scType_ann
seu$seurat_clusters <- seu$scType_ann
```

```{r VizAnn, fig.width = 20, fig.height = 8}
# Save old custom palette for original clusters
n_cl <- n
cols_cl <- cols

# Create custom color palettes
n <- length(unique(Idents(seu)))
cols <- gg_color_hue(n)

# Inspect UMAP scType annotation
p1 <- DimPlot(seu, reduction = "umap", label = FALSE, raster = FALSE, 
              repel = TRUE, cols = cols_cl, group.by = "cl_scType_ann")

p2 <- DimPlot(seu, reduction = "umap", label = FALSE, raster = FALSE, 
              repel = TRUE, cols = cols, group.by = "scType_ann")

# Arrange plots
p1 + p2
```
## Save the Seurat object

```{r SavingSeuObj_clus}
# Save the Seurat object before annotation
name <- paste0("seu_", folder, "_SL.RDS")
saveRDS(seu, here("output","processed_data",folder,name))
```

# Final spatial visualizations

Now that cells have been annotated, visualizing them in their spatial context becomes more informative. For example, all cells can be visualized simultaneously in the sample or one cell type can be specifically highlighted:     

```{r SpatialViz, fig.width = 13, fig.height = 7, , dpi = 300}
## Code adapted from Seurat Spatial vignette
p1 <- ImageDimPlot(seu, fov = "globalFOV", axes = TRUE, cols = cols) +
  theme_classic()

p2 <- ImageDimPlot(seu, fov = "globalFOV", axes = TRUE, cols = cols[2],
                   cells = WhichCells(seu, idents = "Oligodendrocytes")) +
  ggtitle("Oligodendrocyte") + 
  theme_minimal() +
  theme(plot.title = element_text(face = "bold", hjust = 0.5))

# Arrange plots
p1 + p2
```

Another interesting visualization would be to plot gene expression markers in its spatial context. For example, one typical maker for Oligodendrocytes is *Olig1*:

```{r MarkerViz1, fig.width = 7, fig.height = 5}
## Code adapted from Seurat Spatial vignette
## Points are removed from violin plots as CosMx datasets can contain over 1 million cells and may hide the violin plot

VlnPlot(seu, features = "Olig1",pt.size = 0, y.max = 20) + NoLegend()
```
As expected, it is highly expressed in Oligodendrocytes and Oligodendrocyte precursor cells, but it can also be observed in its spatial context:

```{r SpatialViz2, fig.width = 13, fig.height = 7, dpi = 300}
## Code adapted from CosMxLite vignette
p1 <- ImageFeaturePlot(seu, fov = "globalFOV", features = "Olig1") +
  theme_classic() +
  theme(plot.title = element_text(face = "bold", hjust = 0.5))

p2 <- ImageDimPlot(seu, fov = "globalFOV", axes = TRUE, 
                   cols = c(cols[2], cols[8]),
                   cells = WhichCells(seu, 
                                      idents = c("Oligodendrocytes",
                                                 "Oligodendrocyte precursor cells"))) +
  ggtitle("Oligodendrocyte and \n Oligodendrocyte precursor cells") + 
  theme_minimal() +
  theme(plot.title = element_text(face = "bold", hjust = 0.5),
        legend.position = "bottom")

# Arrange plots
p1 + p2
```

# Performance and Session Info

<details>
  <summary>**Performance Report**</summary>
```{r PerformanceReport, echo = FALSE}
# Report dataframe
report_data <- data.table(
  Chunk = names(all_times),
  Time_sec = round(unlist(all_times), 2),
  Memory_Mb = round(unlist(all_mem), 2)
)

# Add total row
total_time <- round(sum(unlist(all_times)), 2)
total_mem <- round(sum(unlist(all_mem)), 2)

new_row <- list("Total", total_time, total_mem)
report_data <- rbindlist(list(report_data, new_row))

# Save as CSV
if(!dir.exists(here("output","performance_reports"))){
  dir.create(here("output","performance_reports"))
}

write.csv(report_data, here("output","performance_reports","4.2_seurat_unsup_clustering_PR.csv"), row.names = FALSE)

# Show table
knitr::kable(report_data, row.names = FALSE, format = "html") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
```
</details>
